# Visualisation III {#visu3}

```{r setup, include=FALSE, echo=FALSE, message=FALSE, results='hide'}
SciViews::R
```

##### Objectifs {-}

- Être capable de réaliser différents graphiques pour représenter des variables facteurs comme le graphique en barres, ou le graphique en camembert dans R avec la fonction `chart()`

- Comprendre et utiliser la boîte de dispersion pour _synthétiser_ la distribution de données numériques 

- Arranger différents graphiques dans une figure unique

- **De manière optionnelle**, découvrir différents systèmes graphiques (graphiques de base, {lattice}, {ggplot2}) et les comparer entre eux

##### Prérequis {-}

Assurez-vous de bien maîtriser les bases relatives à la représentation graphiques vues dans le module \@ref(visu1) et d'être à l'aise dans l'utilisation des outils logiciels (SciViews Box, RStudio, R Markdown, Git & GitHub).

## Graphique en barres

Le graphique en barres (on dit aussi graphique en bâtons) compare les effectifs pour différents niveaux (ou modalités) d'une variable qualitative ou facteur. La différence avec l'histogramme est donc subtile et tient au fait que, pour l'histogramme, nous partons d'une variable quantitative qui est découpée en classes.

### Effectifs par facteur

La question du nombre et/ou de l'intervalle des classes ne se pose pas dans le cas du graphique en barres. Par défaut, les barres seront séparées les unes des autres par un petit espace vide pour bien indiquer visuellement qu'il n'y a pas continuité entre les classes (dans l'histogramme, les barres sont accolées les unes aux autres pour matérialiser justement cette continuité).

La formule que vous utiliserez, ici encore, ne fait appel qu'à une seule variable et s'écrira donc\ :

$$\sim variable \ facteur$$

```{r barres-facteur, fig.cap= "Exemple d'un graphique en barres montrant le dénombrement des niveaux d'une variable facteur, avec les éléments importants du graphique mis en évidence en couleurs.", echo=FALSE, message=FALSE}
zooplankton <- read("zooplankton", package = "data.io", lang = "FR")
copepoda <- filter(zooplankton,
  class %in% c("Calanoïde", "Cyclopoïde",  "Harpacticoïde", "Poecilostomatoïde"))

chart(data = copepoda, ~ class) +
  geom_bar() +
  labs(x = "Label de l'axe x  + [Unité éventuelle]", 
       y = "Effectifs") +
  theme(axis.text.x  = element_text(colour = "#a80039", size = 14), 
        axis.title.x = element_text(colour = "#029687", size = 14), 
        axis.text.y  = element_text(colour = "#a80039", size = 14), 
        axis.title.y = element_text(colour = "#029687", size = 14),
        axis.line.x  = element_line(colour = "#a80039"),
        axis.line.y  = element_line(colour = "#a80039"))
```

Outre les barres elles-mêmes, prêtez toujours attention aux éléments suivants du graphique (ici mis en évidence en couleurs)\ :

- les axes avec les graduations (en rouge)
- les niveaux de la variable facteur (en rouge également)
- le label des axes (en bleu)

Les instructions dans R pour produire un graphique en barres à l'aide de la fonction `chart()` sont les suivantes. Nous partons d'un jeu de données `zooplankton` que nous importons et dont nous extrayons un sous-ensemble à l'aide de la fonction `filter()`(vous étudierez en détail les fonctions de remaniement de tableaux dans les deux prochains modules) avant de réaliser notre graphique à l'aide de `chart()`\ :

```{r barres-facteur2, fig.cap="Abondances de quatres types de copépodes dans un échantillon de zooplancton."}
# Importation du jeu de données
(zooplankton <- read("zooplankton", package = "data.io", lang = "FR"))
# Réduction du jeu de données à quatre classes seulement
(copepoda <- filter(zooplankton,
  class %in% c("Calanoïde", "Cyclopoïde",  "Harpacticoïde",  "Poecilostomatoïde")))
# Réalisation du graphique
chart(data = copepoda, ~ class) +
  geom_bar() +
  xlab("Classe") +
  ylab("Effectifs")
```

La fonction `geom_bar()` se charge d'ajouter les barres verticales dans le graphique. La hauteur de ces barres correspond au nombre d'observations rencontrées dans le jeu de données pour chaque niveau (ou classe, ou groupe) de la variable facteur représentée. Avec cet exemple, vous voyez également au passage comment réduire le nombre de niveaux dans un jeu de données avec `filter()`.

### Effectifs par deux facteurs

Reprenons maintenant le jeu de données `biometry`.

```{r}
# Importation des données biometry
(biometry <- read("biometry", package = "BioDataScience", lang = "FR"))
```

Nous voulons représenter des barres pour les effectifs d'hommes et de femmes dans ce jeu de données (variable `gender`), mais en les séparant par années (variable `year_measure`). C'est faisable, mais notez que, si `gender` est déjà une variable facteur `<fct>`, `year_measure` est encodé comme variable quantitative numérique (c'est un "double" indiqué `<dbl>`, c'est-à-dire un nombre décimal par opposition à entier `<int>`). Or nous devons **absolument utiliser des variables facteur ici**. Nous allons donc effectuer la conversion avec la fonction `as.factor()` avant de réaliser notre graphique en barres. Nous en profitons pour indiquer un `label()` en français pour cette variable.

```{r}
# Conversion de la variable year_measure de numérique à facteur
biometry$year_measure <- as.factor(biometry$year_measure)
label(biometry$year_measure) <- "Année de la mesure"
```

Notez bien comment on se réfère à la variable `year_measure` à l'intérieur du jeu de données `biometry` avec `biometry$year_measure`. Et cette notation peut aussi bien être utilisée pour récupérer la colonne `year_measure` dans un argument d'une fonction (à droite), que comme résultat de l'assignation (à gauche de l'opérateur d'assignation `<-`). Ainsi l'instruction qui transforme en facteur **remplace** la version dans le jeu de données `biometry`. Maintenant, considérons que nous nous intéressons aux mesures antérieures à 2017 (cela nous permettra d'illustrer des points importants relatifs à l'utilisation de variables facteurs).

```{block2, type='note'}
Les variables facteurs sont encodées dans R comme des entiers 1, 2, 3, ... pour les différents niveaux avec en plus, un attribut `levels` qui y associe une description textuelle à chacun des niveaux. Cela peut être perturbant quand la description textuelle est constituée d'un nombre comme ici pour `year_measure`. Mais les calculs sont prohibés sur les variables facteurs.
```

```{r}
tail(biometry)$year_measure
```

Nous utilisons `head()` et `tail()` pour extraire les quelques lignes de début ou de fin d'un tableau. C'est utile pour en réduire la taille à l'impression. Faites très attention\ : lorsque vous imprimez le contenu d'une variable facteur, R *substitue* automatiquement les niveaux 1, 2, 3, ... par le contenu textuel tel qu'indiqué dans la dernière ligne `Levels: ...`, et **l'imprime sans mettre le texte entre guillemets**. Cela peut renforcer la fausse impression que c'est bien des valeurs numériques.

Vous commencez à comprendre que si vous effectuez maintenant la comparaison `year_measure < 2017` lorsque cette variable est encodée comme facteur, ça ne fonctionnera pas comme vous le souhaitez\ ! Si on est chanceux, un message d'erreur ou d'avis ("warning") est imprimé. C'est le cas de `filter()` que nous avons déjà utilisé.

```{r, error=TRUE}
biometry2 <- filter(biometry, year_measure < 2017) 
```

Notez au passage que `filter()` n'utilise pas la notation `biometry$year_measure`, mais prend un premier argument qui est le jeu de données `biometry`, et la suite se réfère aux variables de ce jeu de données telle que `year_measure` en priorité aux autres variables disponibles dans l'environnement utilisateur de R. C'est donc une approche bien plus puissante que la notation traditionnelle. Aussi `filter()` renvoie tout le tableau remanié. Donc, nous devons l'affecté simplement à une variable qui contient ce tableau (`biometry2` ici).

Dans d'autres cas, le résultat peut être dramatique car le calcul est appliqué à l'encodage des niveaux de la variable facteur. Or, avec quatre niveaux, les encodages sont 1, 2, 3 et 4, ... et ils sont bien évidemment tous inférieurs à 2017 (pour rappel, "2013", "2014", "2016" et "2017" sont les libellés textuels des niveaux de la variable facteur)\ !

```{block2, type='warning'}
De manière générale, n'effectuez **jamais** de calcul sur des variables facteurs. Tranformez-les toujours avant. Si les libellés contiennent des valeurs numériques sur lesquelles vous voulez faire des calculs, utilisez `as.numeric(as.character(VARFACT))`, et une fois le calcul réalisé, retransformez en facteur avec `as.factor()`.
```

Le calcul explicite et sûr est donc le suivant\ :

```{r}
# Transforme de manière sûre factor -> numeric (double)
biometry$year_measure <- as.numeric(as.character(biometry$year_measure))
# Filtre les données sur une copie du tableau
biometry2 <- filter(biometry, year_measure < 2017)
# Retransforme en variable factor
biometry2$year_measure <- as.factor(biometry2$year_measure)
# Vérification
tail(biometry2)$year_measure
```

Naturellement ici, la bonne stratégie est d'effectuer le calcul sur le tableau de départ **avant** de transformer en facteur, mais nous sommes partis de la variable facteur à titre d'illustration d'un cas qui peut se rencontrer en pratique. A présent que nous avons notre jeu de données sans les individus de 2017, et les variables correctement encodées, nous pouvons aborder différentes représentations pour observer des dénombrements tenant compte de plusieurs variables facteurs. Par défaut, l'argument `position =` a pour valeur `stack` (donc, lorsque cet argument n'est pas précisé dans `geom_bar()`, les barres sont empilées par rapport à la seconde variable facteur).

```{r barres-2facteurs, echo=TRUE, fig.cap="Dénombrement des hommes (H) et des femmes (F) dans l'étude sur l'obésité en Hainaut, (A) graphique utilisant un seul facteur. (B) graphique prenant en compte les années de mesure."}
a <- chart(data = biometry2, ~ gender) +
  geom_bar() +
  ylab("Effectifs")

b <- chart(data = biometry2, ~ gender %fill=% year_measure) +
  geom_bar() +
  ylab("Effectifs") +
  scale_fill_viridis_d()

combine_charts(list(a, b), common.legend = TRUE)
```

Il existe d'autres options en utilisant les valeurs `dodge` ou `fill` pour l'argument `position =`.

```{r barres-2facteurs2, fig.cap="Dénombrement des hommes (H) et des femmes (F) dans l'étude sur l'obésité en Hainaut en tenant compte des années de mesure (différentes présentations).", echo=TRUE}
a <- chart(data = biometry2, ~ gender %fill=% year_measure) +
  geom_bar(position = "stack") +
  ylab("Effectifs") +
  scale_fill_viridis_d()

b <- chart(data = biometry2, ~ gender %fill=% year_measure) +
  geom_bar(position = "dodge") +
  ylab("Effectifs") +
  scale_fill_viridis_d()

c <- chart(data = biometry2, ~ gender %fill=% year_measure) +
  geom_bar(position = "fill") +
  ylab("Fractions") +
  scale_fill_viridis_d()

combine_charts(list(a, b, c), common.legend = TRUE)
```

Soyez vigilant à la différence entre l'argument `position = stack` et `position = fill` qui malgré un rendu semblable ont l'axe des ordonnées qui diffèrent (dans le cas de `fill`, il s'agit de la **fraction** par rapport au total qui est représentée, et non pas des **effectifs** absolus dénombrés).

##### Pièges et Astuces {-}

###### Réordonner la variable facteur par fréquence {-}

Vous pouvez avoir le souhait d'ordonner votre variable facteur afin d'améliorer le rendu visuel de votre graphique. Pour cela, vous pouvez employer la fonction `fct_infreq()`. 

```{r barres-facteur-ordonné, fig.cap="Dénombrement des classes de copépodes du jeu de données zooplankton."}
chart(data = copepoda, ~ fct_infreq(class)) +
  geom_bar() +
  labs(x = "Classe", y = "Effectifs")
```

###### Rotation des axes du graphique en barre {-}

Lorsque les niveaux dans la variable étudiée sont trop nombreux, les légendes en abscisse risquent de se chevaucher, comme dans la Fig. \@ref(fig:barchart1)

```{r barchart1, fig.cap="Dénombrement des classes du jeu de données zooplankton."}
chart(data = zooplankton, ~ class) +
  geom_bar() +
  ylab("Effectifs")
```

Dans ce cas, il est possible de réaliser un graphique en **barres horizontales** qui laisse plus de place pour le libellé sur l'axe. Il existe deux manières de le faire\ : préférentiellement en utilisant l'argument `orientation = "y"` de `geom_bar()` (mais alors il faut utiliser `aes(y = ...)` à la place de la formule), et ensuite, on peut garder tout le code identique, mais rajouter `coord_flip()` tout à la fin. Utilisons successivement ces deux approches.

```{r barres-rotation, fig.cap="Dénombrement des classes du jeu de données zooplankton (version avec barres horizontales en utilisant `orientation = \"y\"`)."}
chart(data = zooplankton, aes(y = class)) +
  geom_bar(orientation = "y") +
  xlab("Effectifs")
```

Pourquoi ne peut-on pas utiliser de formule dans ce cas\ ? En fait, il faudrait écrire `class ~`, ... seulement voilà, une formule ne *peut pas* avoir un membre de droite vide. Donc, on est dans une impasse et on doit utiliser la forme explicite `aes()` pour "aesthetics" en anglais qui indique quelle variable est utilisée pour quoi dans le graphique en indiquant `y=`.

Avec la fonction `coord_flip()` ajoutée à votre graphique, vous pouvez effectuer une rotation des axes (l'axe X devient Y et inversément) pour obtenir un **graphique en barres horizontales**. De plus, l’œil humain perçoit plus distinctement les différences de longueurs horizontales que verticales. Donc, de ce point de vue, le graphe en barres horizontales est considéré comme meilleur que le graphe en barres verticales.

```{r barres-rotation2, fig.cap="Dénombrement des classes du jeu de données zooplankton (version avec barres horizontales en utilisant `coord_flip()`)."}
chart(data = zooplankton, ~ class) +
  geom_bar() +
  ylab("Effectifs") +
  coord_flip()
```

```{block2, type='warning'}
Avec `coord_flip()`, pensez toujours que vos axes *finaux* X et Y sont inversés avant l'utilisation de cette instruction. Ainsi, si vous voulez changer le libellé de l'axes X sur le graphique final, mais *avant* d'avoir indiqué `coord_flip()`, gardez bien à l'esprit que c'est en fait le libellé de l'axe Y que vous devez indiquer avec, par exemple `ylab()` comme c'est le cas dans la figure précédente pour le libellé "Effectifs".
```

##### Pour en savoir plus {-}

- [Graphes en barres à l'aide de ggplot2](http://www.sthda.com/french/wiki/ggplot2-barplots-guide-de-demarrage-rapide-logiciel-r-et-visualisation-de-donnees). Un tutoriel en français utilisant la fonction `ggplot()`. L'annotation des barres est également présentée.

- [Page d'aide de la fonction `geom_bar()`](http://ggplot2.tidyverse.org/reference/geom_bar.html) en anglais.

### Valeurs moyennes  {#barres-mean}

Le graphique en barres peut être aussi employé pour résumer des données numériques via la moyenne. Il ne s'agit plus de dénombrer les effectifs d'une variable facteur mais de résumer des données numériques en fonction d'une variable facteur. On peut exprimer cette relation dans R sous la forme de\ :

$$y \sim x$$

que l'on peut lire\ :

$$y \ en \ fonction \ de \ x$$

Avec _y_ une variable numérique et _x_ une variable facteur. Considérez l'échantillon suivant\ :

```
1, 71, 55, 68, 78, 60, 83, 120, 82 ,53, 26
```

Calculez la moyenne sur base de la formule de la moyenne

$$\overline{y} = \sum_{i = 1}^n \frac{y_i}{n}$$


```{r}
# Création du vecteur
x <- c(1, 71, 55, 68, 78, 60, 83, 120, 82, 53, 26)
# Calcul  de la moyenne
mean(x)
```

Les instructions pour produire ce graphe en barres à l'aide de `chart()` sont\ :

```{r barres-mean, fig.cap="Exemple de graphique en barres représentant les moyennes de tailles par groupe zooplanctonique."}
chart(data = copepoda, size ~ class) +
  stat_summary(geom = "col", fun = "mean") +
  xlab("Classe")
```

Ici, nous faisons appel à une autre famille de fonctions\ : celles qui effectuent des calculs sur les données avant de les représenter graphiquement. Leurs noms commencent toujours par `stat_`.

```{block2, type='warning'}
Le graphe en barres pour représenter les moyennes est très répandu dans le domaine scientifique malgré le grand nombre d'arguments en sa défaveur et que vous pouvez lire dans la section **pour en savoir plus** ci-dessous. L'un des arguments le plus important est la faible information qu'il véhicule puisque l'ensemble des données n'est plus représenté que par une valeur (la moyenne) pour chaque niveau de la variable facteur. Pour un petit nombre d'observations, il vaut mieux toutes les représenter à l'aide d'un nuage de points. Si le nombre d'observations devient très grand (dizaines ou plus), le graphique en boites de dispersion est plus indiqué (voir plus loin dans ce module).
```

##### À vous de jouer ! {-}

`r learnr("A04La_barres", title = "Graphique en barres", toc = "Graphiques en barres")`

##### Pour en savoir plus {-} 

- [Beware of dynamite](http://users.stat.umn.edu/~rend0020/Teaching/STAT8801-2015Spring/handouts/24-dynamite.pdf). Démonstration de l'impact d'un graphe en barres pour représenter la moyenne (et l'écart type) = graphique en "dynamite".

- [Dynamite plots: unmitigated evil?](http://emdbolker.wikidot.com/blog%3Adynamite) Une autre comparaison du graphe en dynamite avec des représentations alternatives qui montre que le premier peut avoir quand même quelques avantages dans des situations particulières.

## Graphique en camembert

Le graphique en camembert (ou en parts de tarte, ou encore appelé diagramme circulaire, *pie chart* en anglais) vous permettra de visualiser un dénombrement d'observations par facteur, tout comme le graphique en barres. 

```{r piechart, fig.cap="Exemple de graphique en camembert montrant les effectifs des niveaux d'une variable facteur."}
chart(data = copepoda, ~ factor(0) %fill=% class) +
  geom_bar(width = 1) + 
  coord_polar("y", start = 0) +
  theme_void() +
  scale_fill_viridis_d()
```

Ce graphique est plus difficile à réaliser à l'aide de `chart()` ou `ggplot()`. En fait, il faut ruser ici, et l'auteur du package {ggplot2} n'avait tout simplement pas l'intention d'ajouter ce type de graphique dans la panoplie proposée. En effet, il faut savoir que l’œil humain est nettement moins bon pour repérer des angles que pour comparer des longueurs. **Donc, le diagramme en barres est souvent meilleur pour comparer des effectifs par classes.** Mais d'une part, le graphique en camembert est (malheureusement) un graphique très répandu et il faut savoir l'interpréter, et d'autre part, il peut s'avérer quand même utile dans certaines situations. Notez l'utilisation des fonctions `coord_polar()` qui crée des coordonnées polaires et la fonction `theme_void()` qui crée un graphique sans axes. En fait, un graphique en camembert peut aussi se concevoir comme un graphique en barres représenté en coordonnées polaires.

##### Pièges et astuces {-}

Partons d'un exemple fictif pour vous convaincre qu'un graphique en barres est souvent plus lisible qu'un graphique en camembert. Combien d'observations comptez-vous pour la lettre **H**\ ?

```{r, echo=FALSE}
df <- tibble(
  Index    = 1:347,
  Facteur  = as.factor(rep(LETTERS[1:10],
    times = c(10, 1, 1, 50, 2, 78, 101, 24, 31, 49)
  ))
)
```

```{r piechart2, echo=FALSE, fig.cap="Arrivez-vous à lire facilement des valeurs sur un graphique en camenbert (une échelle y est ajoutée de manière exceptionnelle pour vous y aider)."}
chart(data = df, ~ factor(0) %fill=% Facteur) +
  geom_bar(width = 1) + 
  coord_polar("y", start = 0) +
  labs( x = "", y = "") +
  scale_fill_viridis_d()
```

Maintenant, effectuez le même exercice sur base d'un graphique en barres, combien d'observations pour la lettre **H**\ ?

```{r barchart2, echo=FALSE, fig.cap="Dénombrement des niveaux d'une variable facteur sur un graphique en barres."}
chart(data = df, ~ Facteur %fill=% Facteur) +
  geom_bar(width = 1) +
  ylab("Effectifs") +
  scale_fill_viridis_d()
```

Dans ce dernier cas, c'est bien plus facile\ : il y a effectivement 24 observations relatives à la lettre **H** (vous ne voyez peut-être pas que l'effectif de *H* est exactement 24, mais vous pouvez voir sans problème qu'il est d'*environ* 25, alors que sur le graphique en camembert, nous le voyons beaucoup moins bien).

##### À vous de jouer ! {-}

`r learnr("A04Lb_camembert", title = "Graphique en camembert", toc = "Graphiques en camembert")`

##### Pour en savoir plus {-} 

- [Graphique en camembert à l'aide de la fonction `ggplot()`](http://www.sthda.com/french/wiki/ggplot2-graphique-en-camembert-guide-de-demarrage-rapide-logiciel-r-et-visualisation-de-donnees). Explications en français des différentes étapes pour passer d'un graphique en barres à un graphique en camembert avec **ggplot2**.

- [Autre explication](https://dataparkblog.wordpress.com/2017/09/24/diagramme-en-camembert-avec-r-et-ggplot/) en français, également accompagnée d'informations sur les bonnes pratiques en matière de graphique en camembert.

- [Save the pies for dessert](http://www.perceptualedge.com/articles/08-21-07.pdf) est une démonstration détaillée des méfaits du graphique en camembert (le graphique en camembert, un graphique puant ? Pourrait-on peut-être titrer en français).

- [Les côtés positifs du graphe en camembert](https://www.displayr.com/why-pie-charts-are-better-than-bar-charts/) sont mis en évidence dans ce document (en anglais).

## Boite de dispersion {#boxplot}

Vous souhaitez représenter graphiquement cette fois *un résumé* d'une variable numérique mesurée sur un nombre (relativement) important d'individus, soit depuis une dizaine jusqu'à plusieurs millions. Vous souhaitez également conserver de l'information sur la distribution des données, et voulez éventuellement comparer plusieurs distributions entre elles\ : soit différentes variables, soit différents niveaux d'une variable facteur. Nous avons déjà vu au module \@ref(visu2) les diagrammes en violon et en lignes de crêtes pour cet usage. Nous allons étudier ici les **boites de dispersion** (encore appelée boite à moustaches) comme option alternative intéressante. La boite de dispersion représentera graphiquement cinq descripteurs communément appelés les **cinq nombres**.

Considérez l'échantillon suivant\ :

```
1, 71, 55, 68, 78, 60, 83, 120, 82 ,53, 26
```

Ordonnons-le de la plus petite à la plus grande valeur\ :

```{r}
# Créer du vecteur
x <- c(1, 71, 55, 68, 78, 60, 83, 120, 82, 53, 26)
# Ordonner le vecteur par ordre croissant
sort(x)
```

Le premier descripteur des cinq nombres est la **médiane** qui est la valeur se situant à la moitié des observations, donc, avec autant d'observations plus petites et d'observations plus grande qu'elle. La médiane sépare l'échantillon en deux.

```{r}
median(x)
```

En effet, nous voyons sur le vecteur ordonné que cinq valeurs sont plus petites que 68 et cinq valeurs sont plus grandes. Les quartiles séparent l'échantillon en quatre. Le **premier quartile** (Q1) sera la valeur pour laquelle 25% des observations seront plus petites. Elle se situe donc entre la valeur minimale et la médiane. Cette médiane est égale au second quartile (50% des observations plus petites). Le **troisième quartile** (Q3) est la valeur pour laquelle 75% des observations de l'échantillon sont plus petites^[Notez que, lorsque la coupure tombe entre deux observations, une valeur intermédiaire est utilisée. Ici par exemple, le premier quartile est entre 53 et 55, donc, il vaut 54. Le troisième quartile se situe entre 78 et 82. Il vaut donc 80.]. Enfin, la valeur **minimale** et la valeur **maximale** observées dans l'échantillon complètent ces cinq nombres qui décrivent de manière synthétique la *position* et l'*étendue* des observations.

```{block2, type='note'}
Les **cinq nombres** sont : la **valeur minimale**, le **premier quartile**, la **médiane** (ou deuxième quartile), le **troisième quartile** et la **valeur maximale**.
```

Voici comment on les calcules facilement dans R\ :

```{r}
fivenum(x)
```

La boite de dispersion est une représentation graphique codifiée de ces cinq nombres. La représentation de `x` sous forme de nuage de points n'est ni très esthétique, ni très lisible, surtout si nous avons affaire à des milliers ou des millions d'observations qui se chevauchent sur le graphique^[Il est possible de modifier la transparence des points et/ou de les déplacer légèrement vers la gauche ou vers la droite de manière aléatoire pour résoudre le problème de chevauchement des points sur un graphique en nuage de points univarié.].

```{r nuage-de-points, fig.cap="Nuage de points univarié.", echo=FALSE}
df <- tibble(x = x)
chart(data = df, x ~ 0) +
  geom_point() +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.text.x.top = element_blank()) +
  labs(x = "", y = "")
```

La boite de dispersion va remplacer cette représentation peu lisible par un objet géométrique qui représente les cinq nombres.

```{r boxplot-construct, fig.cap="A) Nuage de points annoté avec les cinq nombres représentés par des traits horizontaux. B) Boite de dispersion obtenue pour les même données que A.", echo=FALSE}

a <- chart(data = df, x ~ 0) +
  geom_point() +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.text.x.top = element_blank()) +
  labs(x = "", y = "") + 
  geom_hline(yintercept = fivenum(x)) +
  geom_hline(yintercept = median(x), size = 1.3)

b <- chart(df, x ~ 0) +
  geom_boxplot(outlier.colour = "#a80039", fill = "#029687") +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.text.x.top = element_blank()) +
  labs(x = "", y = "")

combine_charts(list(a, b))
```

Vous observez à la Fig. \@ref(fig:boxplot-construct) que certaines valeurs minimales et maximales ne sont pas reliées à la boite de dispersion, il s'agit de **valeurs extrêmes**.

```{block2, type='note'}
**Règle pour déterminer s'il y a des valeurs extrêmes avec une boite de dispersion\ :** une valeur est considérée comme extrême si son écart par rapport à la boite est supérieur à une fois et demi la hauteur de la boite (encore appelée **espace inter-quartile** IQR correspondant à Q3 - Q1). Les tiges (ou "moustaches") qui prolongent la boite de dispersion s'arrêtent donc aux dernières valeurs les plus petites et plus grandes, mais qui rentrent encore dans une fois et demi l'IQR. Les valeurs extrêmes sont ensuite représentées individuellement par un point au dessus et en dessous.
```

```{r, echo=FALSE, message=FALSE, warning=FALSE}
# https://www.r-bloggers.com/exploring-ggplot2-boxplots-defining-limits-and-adjusting-style/
ggplot_box_legend <- function(family = "sans") {
  # Create data to use in the boxplot legend
  set.seed(100)
  sample_df <- data.frame(
    parameter = "test",
    values    = sample(500))
  
  # Extend the top whisker a bit
  sample_df$values[1:100] <- 701:800
  # Make sure there's only 1 lower outlier
  sample_df$values[1] <- -350
  
  # Function to calculate important values
  ggplot2_boxplot <- function(x) {
    quartiles <- as.numeric(quantile(x, probs = c(0.25, 0.5, 0.75)))
    
    names(quartiles) <- c("1er quartile", 
      "2ème quartile\n(médiane)", "3ème quartile")
    
    IQR <- diff(quartiles[c(1, 3)])
    
    upper_whisker <- max(x[x < (quartiles[3] + 1.5 * IQR)])
    lower_whisker <- min(x[x > (quartiles[1] - 1.5 * IQR)])
    
    upper_dots <- x[x > (quartiles[3] + 1.5 * IQR)]
    lower_dots <- x[x < (quartiles[1] - 1.5 * IQR)]
    
    list("quartiles" = quartiles,
         "1er quartile" = as.numeric(quartiles[1]),
         "2ème quartile\n(médiane)" = as.numeric(quartiles[2]),
         "3ème quartile" = as.numeric(quartiles[3]),
         "IQR" = IQR,
         "moustache supérieure" = upper_whisker,
         "moustache inférieure" = lower_whisker,
         "extrêmes hauts" = upper_dots,
         "extrêmes bas" = lower_dots)
  }
  
  # Get those values
  ggplot_output <- ggplot2_boxplot(sample_df$values)
  
  # Lots of text in the legend, make it smaller and consistent font
  update_geom_defaults("text", list(size = 3, hjust = 0, family = family))
  # Labels don't inherit text
  update_geom_defaults("label", list(size = 3, hjust = 0, family = family))
  
  # Create the legend
  # The main elements of the plot (the boxplot, error bars, and count)
  # are the easy part.
  # The text describing each of those takes a lot of fiddling to
  # get the location and style just right:
  explain_plot <- ggplot() +
    stat_boxplot(data = sample_df,
      aes(x = parameter, y = values),
      geom = 'errorbar', width = 0.3) +
    geom_boxplot(data = sample_df,
      aes(x = parameter, y = values), 
      width = 0.3, fill = "#029687") +
    theme_minimal(base_size = 5, base_family = family) +
    geom_segment(aes(
      x = 2.3, xend = 2.3, 
      y = ggplot_output[["1er quartile"]], 
      yend = ggplot_output[["3ème quartile"]])) +
    geom_segment(aes(
      x = 1.2, xend = 2.3, 
      y = ggplot_output[["1er quartile"]], 
      yend = ggplot_output[["1er quartile"]])) +
    geom_segment(aes(
      x = 1.2, xend = 2.3, 
      y = ggplot_output[["3ème quartile"]], 
      yend = ggplot_output[["3ème quartile"]])) +
    geom_text(aes(
      x = 2.4,
      y = ggplot_output[["2ème quartile\n(médiane)"]]), 
      label = "Espace\ninter-quartile",
      fontface = "bold",
      vjust = 0.4) +
    geom_text(aes(
      x = c(1.17,1.17), 
      y = c(ggplot_output[["moustache supérieure"]],
            ggplot_output[["moustache inférieure"]]), 
      label = c(
        "Plus grande valeur comprise dans 1.5 fois\nl'espace inter-quartile\nau dessus du 3ème quartile",
        "Plus petite valeur comprise dans 1.5 fois\nl'espace inter-quartile\nen dessous du 1er quartile")),
      fontface = "bold",
      vjust = 0.9) +
    geom_text(aes(
      x = c(1.17), 
      y =  ggplot_output[["extrêmes bas"]], 
      label = "Valeur extrême"), 
      fontface = "bold",
      vjust = 0.5) +
    #geom_text(aes(
    #  x = c(1.95), 
    #  y =  ggplot_output[["extrêmes bas"]], 
    #  label = " valeur < 1.5 fois\nl'espace inter-quartile"), 
    #  vjust = 0.5) +
    geom_label(aes(
      x = 1.17,
      y = ggplot_output[["quartiles"]], 
      label = names(ggplot_output[["quartiles"]])),
      vjust = c(0.4, 0.85, 0.4),
      fill = "white",
      label.size = 0) +
    ylab("") + xlab("") +
    theme(axis.text = element_blank(),
          axis.ticks = element_blank(),
          panel.grid = element_blank(),
          aspect.ratio = 4/3,
          plot.title = element_text(hjust = 0.5, size = 10)) +
    coord_cartesian(xlim = c(1.4,3.1), ylim = c(-600, 900)) +
    labs(title = "Description")
  
  explain_plot
}
```

La boite de dispersion finale ainsi que sa description sont représentées à la Fig. \@ref(fig:boxplot-desc) ci-dessous.

```{r boxplot-desc, fig.cap="A) Boite de dispersion pour `x` et B) description des différents éléments constitutifs.", echo=FALSE}
a <- chart(df, x ~ 0) +
  stat_boxplot(geom = 'errorbar', width = 0.3) +
  geom_boxplot(fill = "#029687", width = 0.3) +
  theme(axis.text.x     = element_blank(),
        axis.ticks.x    = element_blank(), 
        axis.text.x.top = element_blank()) +
  labs(x = "Label de l'axe x", y = "Label de l'axe y [unité]")
b <- ggplot_box_legend()

combine_charts(list(a, b))
```

Un des gros avantages de la boite de dispersion est de mettre en évidence de manière synthétique la distribution des données sur l'axe. La **boite de dispersion parallèle** places *plusieurs* boites de dispersion côte à côte en face d'un même axe. C'est un excellent moyen de *comparer* la dispersion de données numériques en fonction des niveau d'une variable **factor**.  Les instructions dans R pour produire un graphique en boites de dispersion parallèles sont\ :

```{r boxplot, fig.cap="Distribution des tailles par groupes taxonomiques pour le zooplancton."}
chart(data = copepoda, size ~ class) +
  geom_boxplot()
```

La formule à employer est `YNUM (size) ~ XFACTOR (class)`. Ensuite, pour réaliser une boite de dispersion vous devez ajouter la fonction `geom_boxplot()`.

### Taille de l'échantillon

Lors de la réalisation de boites de dispersion, vous devez être vigilant au nombre d'observations qui se cachent sous chacune d'elles. En effet, réaliser une boite de dispersion à partir d'échantillons ne comportant que cinq valeurs ou moins n'a *aucun* sens\ ! 

```{r boxplot-points, fig.cap= "Piège des boites de dispersion : trop peu d'observations disponibles pour `a`.", echo= FALSE}
df <- tibble(
  Facteur = rep(c("A", "B", "C"), times = c(4, 11, 8)), 
  Valeur  = c(55, 83, 120, 26, 1, 71, 55, 68, 78, 60, 83, 120,
              82, 53, 26, 1, 71, 78, 60, 83, 120, 53, 26))
chart(data = df, Valeur ~ Facteur) +
  geom_boxplot() +
  geom_point(color = "red") 
```

La boite de dispersion pour le niveau **`A`** est calculée à partir de seulement quatre observations. C'est trop peu. Comme les points représentant les observations ne sont habituellement pas superposés à la boite, cela peut passer inaperçu et tromper le lecteur\ ! Une bonne pratique consiste à ajouter *n*, le nombre d'observations au-dessus de chaque boite. Cela peut se faire facilement avec les fonctions `give_n()` et `stat_summary()` ci-dessous^[La fonction `give_n()` est une **fonction personnalisée** que nous avons écrite nous-même. Elle positionne du texte `y=` 10% plus haut que le `max(x)`, et ce texte est `length(x)`, la longueur du vecteur qui correspond au nombre d'observations pour `x` (`x`étant utilisé en interne par le moteur graphique). Il est possible, et même assez facile, dans R d'écrire ses *propres* fonctions. Néanmoins cela dépasse du cadre du cours pour l'instant. Pour utiliser `give_n()` dans vos documents R Markdown, copiez simplement sa définition dans un chunk avant de l'utiliser comme c'est fait ici. Elle est aussi réutilisable plus loin dans le même R Markdown, une fois qu'elle est définie.].

```{r boxplot2, fig.cap="Taille de copépodes pour différents groupes taxonomiques (le nombre d'observations est indiqué au dessus de chaque boite)."}
give_n <- function(x)
  c(y = max(x) * 1.1, label = length(x)) 

chart(data = copepoda, size ~ class) +
  geom_boxplot() + 
  stat_summary(fun.data = give_n, geom = "text", hjust = 0.5)
```

La fonction `stat_summary()` ajoute des éléments à un graphique sur base d'un *calcul*. Ici, nous rajoutons du texte `geom = "text"`, sur base du calcul effectué avec notre fonction `give_n()` définie plus haut. L'argument `hjust = 0.5` indique simplement que le texte doit être justifié horizontalement à 0.5 (= centré, car 0 = justification à gauche, et 1 = justification à droite).

### En fonction de deux facteurs

La Fig. \@ref(fig:boxplot-tooth) présente un graphique en boites de dispersion parallèles qui combine l'usage de *deux* variables facteurs différentes.

```{r}
# Importation du jeu de données ToothGrowth
(tooth_growth <- read("ToothGrowth", package = "datasets"))
# Remaniement et labelisation du jeu de données
tooth_growth$dose <- as.ordered(tooth_growth$dose)
tooth_growth <- labelise(tooth_growth, self = FALSE,
  label = list(
    len = "Longueur des dents",
    supp = "Supplémentation",
    dose = "Dose"
  ),
  units = list(
    len = "mm",
    supp = NA,
    dose = "mg/J"
  )
)
```

Petits commentaires sur ce code\ :

- La fonction `labelise()` appliquée au tableau tout entier et avec l'argument `self= FALSE` s'applique aux **colonnes** du tableau, c'est-à-dire aux variables. Ensuite, les arguments `label=` et `units=` reçoivent une `list()` nommée pour en modifier les attributs (`nom = "valeur"`). C'est une manière pratique et efficace de changer tous les labels et unités des variables en une seule étape (il n'est pas indispensable de reprendre *toutes* lesvariables, on peut indiquer seulement celles que l'on veut modifier).
 
- Nous avons utilisé `as.ordered()` à la place de `as.factor()`. Les objets "facteurs ordonnés" dans R (ou **ordered**) sont identiques aux facteurs à ceci près que l'ordre de niveaux a aussi un sens du plus petit au plus grand. Ainsi, des niveaux de `supp`\ : soit "VC" pour vitamine C ou "OJ" pour vitamine C dans du jus d'orange n'ont pas d'ordre précis. Nous utilisons un objet **factor**.  Par contre, les doses de vitamines C `0.5 < 1 < 2` exprimées en mg/J ont un ordre. Dans ce cas, nous préférons les objets **ordered**, qui s'utilisent en pratique comme les objets **factor** dans R (mais notez bien l'indication de l'ordre des niveaux de la variable à l'aide de `<` dans `Levels:`, c'est ce qui distingue un objet **ordered** d'un objet **factor**).

```{r}
head(tooth_growth)$dose
```

```{r boxplot-tooth, fig.cap=" Croissance de dents de cochons d'Inde en fonction de la supplémentation (OJ = jus d'orange, VC = vitamine C) et de la dose administrée (nombre d'observations *n* indiqué au dessus de chaque boite)."}
# Réalisation du graphique (nous réutilisons give_n() ici!)
chart(data = tooth_growth, len ~ supp %fill=% dose) +
  geom_boxplot() +
  stat_summary(fun.data = give_n, geom = "text", hjust = 0.5,
    position = position_dodge(0.75))
```

##### À vous de jouer ! {-}

`r learnr("A04Lc_boxplot", title = "Boite de dispersion", toc = "Boites de dispersion")`

##### Pour en savoir plus {-} 

- [Un tutoriel boites de dispersion à l'aide de `ggplot()`](http://www.sthda.com/french/wiki/ggplot2-box-plot-guide-de-demarrage-rapide-logiciel-r-et-visualisation-de-donnees) présentant encore bien d'autres variantes possibles.

- [Box plots in `ggplot2`](https://plot.ly/ggplot2/box-plots/). Autre explication en anglais avec sortie utilisant {plotly}.

- [Grouped box plots](http://www.r-graph-gallery.com/265-grouped-boxplot-with-ggplot2/).

- [Explication plus détaillée sur les cinq nombres](https://chemicalstatistician.wordpress.com/2013/08/12/exploratory-data-analysis-the-5-number-summary-two-different-methods-in-r-2/), en anglais.

## Figures composées

Il arrive fréquemment de vouloir combiner plusieurs graphiques dans une même figure.
Plusieurs fonctions sont à votre disposition pour cela. Il faut tout d'abord distinguer deux types de figures multi-graphiques\ :

1. Soit il s'agit d'un seul graphique que vous souhaitez subdiviser par rapport à une ou plusieurs variables facteurs.
2. Soit il s'agit de graphiques indépendants que vous souhaitez assembler dans une même figure parce que les données ont un lien entre elles, ou parce que ces graphiques sont complémentaires pour comprendre les données.

Dans le premier cas, les fonctions `facet_XXX()` comme `facet_grid()` peuvent être employées (ou l'opérateur `|` dans une formule). Dans le second cas, la fonction `combine_charts()` est l'une des alternatives possibles.

### Facettes

L'une des règles les plus importantes que vous devez impérativement garder à l'esprit lors de la réalisation de vos graphiques est *la simplicité*. Plus votre graphique contiendra d'information, plus il sera compliqué à décoder par vos lecteurs. 

```{r chick1, fig.cap= "Croissance de poulets en utilisant quatre aliments différents."}
# Importation de données relative à la croissance de poulets
(chick_weight <- read("ChickWeight", package = "datasets"))
# Réalisation du graphique (points semi-transparents)
chart(data = chick_weight, weight ~ Time %col=% Diet) +
  geom_point(alpha = 0.5) +
  labs(x = "Age [j]", y = "Masse [g]")
```

Le graphique à la Fig. \@ref(fig:chick1) est mal adapté pour montrer les différences entre les quatre aliments\ : tous les points sont entremêlés. Il peut typiquement être simplifié en utilisant des facettes pour représenter les résultats relatifs aux différents régimes alimentaires sur des graphiques séparés. L'information est la même mais la lecture est beaucoup plus aisée.

```{r chick-facette, fig.cap= "Croissance de poulets en utilisant quatre aliments différents (1-4)."}
chart(data = chick_weight, weight ~ Time | Diet) +
  geom_point(alpha = 0.5) +
  labs(x = "Age [j]", y = "Masse [g]")
```

Vous observez que les échelles en abscisse et en ordonnée sont similaires sur tous les graphiques. Cela permet une meilleure comparaison. Notez toutefois que, plus le nombre de facettes augmente, plus chaque graphique individuel devient petit. Faites attention à ne pas finir avec des graphiques individuels tellement petits qu'ils en deviennent illisibles\ !

### Graphiques assemblés

La fonction `combine_charts()` permet de combiner plusieurs graphiques dans une figure unique. Nous l'avons déjà utilisée à plusieurs reprises. Cette fonction attend une liste (`list()`) de graphiques de type `chart()` à assembler, et il est possible d'en combiner les légendes à l'aide de `common.legend = TRUE`.

```{r combine-charts, fig.cap= "A) Masse d'oursins en fonction de leur taille  et de leur origine. B) Masse totale en fonction de la masse des parties solides de ces mêmes oursins."}
# Importation des données
urchin <- read("urchin_bio", package = "data.io", lang = "FR")
# Réalisation des graphiques
a <- chart(data = urchin, weight ~ height %col=% origin) +
  geom_point()

b <- chart(data = urchin, weight ~ solid_parts %col=% origin) +
  geom_point()

# Combinaison des graphiques dans une même figure
combine_charts(list(a, b), common.legend = TRUE)
```

Il existe d'autres fonctions permettant de combiner plusieurs graphiques comme [`plot_grid()`](https://cran.r-project.org/web/packages/cowplot/vignettes/plot_grid.html) du package {cowplot}, mais avec `combine_charts()` vous pourrez déjà faire beaucoup. De plus, un libellé sous forme d'une lettre majuscule est automatiquement associé à chaque sous-région de la figure composée. Cela permet d'y faire plus facilement référence dans le texte et/ou dans la légende.

##### À vous de jouer ! {-}

`r learnr("A04Ld_fig_composees", title = "Graphiques composés", toc = "Graphiques composés")`

```{r, echo=FALSE, results='asis'}
if (exists("assignation"))
  assignation("A04Ga_graphe_avance", part = NULL,
    url = "https://github.com/BioDataScience-Course/A04Ga_graphe_avance",
    course.urls = c(
      'S-BIOG-006' = "https://classroom.github.com/a/eKp2zsPG",
      'S-BIOG-921' = "https://classroom.github.com/a/3EMyegs8"),
    toc = "Graphiques avancés et libres")
```

##### Pour en savoir plus {-} 

- [Partitionnement des graphiques en facettes](http://www.sthda.com/french/wiki/ggplot2-facet-diviser-un-graphique-en-plusieurs-panneaux-logiciel-r-et-visualisation-de-donnees). Différentes options sont présentées ici.

- [Figures composées à l'aide de `grid.arrange()`](http://lightonphiri.org/blog/ggplot2-multiple-plots-in-one-graph-using-gridextra). Une autre option, mais moins flexible et moins riche que `combine_charts()`. 

- [Figures composées à l'aide de `plot_grid()`](https://wilkelab.org/cowplot/reference/plot_grid.html) avec les différentes options, aussi disponibles avec `combine_charts()`.

- [Troisième possibilité pour des figures composées à l'aide de `ggarrange()`](http://www.sthda.com/english/rpkgs/ggpubr/reference/ggarrange.html). `combine_charts()` fait la même chose, mais avec des valeurs par défaut légèrement différentes (`labels = "auto"` par défaut pour ce dernier, mais `labels = NULL` pour `ggarrange()`). 

## Différents moteurs graphiques

<center>

![Prolifération des standards d'après [xkcd](https://xkcd.com/927/).](https://imgs.xkcd.com/comics/standards.png)

</center>

Depuis le début, l'ensemble des graphiques que nous vous avons proposés utilise la fonction `chart()` du package {chart}. Cependant, il ne s'agit pas de la seule fonction permettant de réaliser des graphiques dans R, loin de là. En fait, {chart} est tout récent et a été développé pour homogénéiser autant que possible les graphiques issus de trois moteurs graphiques différents\ : {ggplot2}, {lattice} et les graphiques de base. La fonction `chart()` a d'autres avantages également\ :

- Un thème par défaut qui est le plus proche possible d'un rendu typique d'une publication scientifique.
- La possibilité d'utiliser l'interface formule avec {ggplot2}.
- La cohérence des objets graphiques obtenus qui peuvent tous êtres combinés en une figure composée, même si ils sont produits avec des moteurs graphiques différents.
- Un libellé automatique des axes et autres éléments du graphique en fonction des attributs `label` et `units` des variables (pour l'instant, seulement les graphiques de type {ggplot2}).

```{r chart-example, fig.cap= "Graphique typique obtenu avec `chart()` : rendu par défaut publiable tel quel, et libellé automatique des axes avec les unités."}
# Importation des données
(urchin <- read("urchin_bio", package = "data.io", lang = "FR"))
# Réalisation du graphique
chart(data = urchin, height ~ weight %col=% origin) + 
  geom_point() 
```

### {ggplot2}

Le moteur graphique {[ggplot2](https://ggplot2.tidyverse.org)} est écrit pas Hadley Wickham, un personnage emblématique de la "révolution [tidyverse](https://www.tidyverse.org)" qui propose une surcouche moderne au dessus de R. {ggplot2} implémente une "grammaire graphique" particulièrement puissante et flexible, proposée et popularisée par le statisticien Leland Wilkinson. Par défaut, `chart()` crée en réalité un graphique {ggplot2} adapté. Voici la version {ggplot2} standard du même graphique représenté à la Fig. \@ref(fig:chart-example) :

```{r ggplot2-example, fig.cap= "Graphique typique obtenu avec `ggplot()` (moteur graphique {ggplot2})."}
ggplot(data = urchin, mapping = aes(x = weight, y = height, col = origin)) + 
  geom_point() 
```

En comparant les Figs. \@ref(fig:chart-example) et \@ref(fig:ggplot2-example) (en faisant abstraction des instructions R utilisées pour l'instant), plusieurs éléments sautent immédiatement aux yeux\ :

- Le thème par défaut de {ggplot2} est très reconnaissable avec un quadrillage blanc sur fond gris clair. On aime ou on n'aime pas, mais il est évident que (1) ce n'est pas une présentation "standard" d'un graphique scientifique, et (2) le thème tord un peu le cou à une règle importante pour réaliser un graphique de qualité\ : **minimiser la quantité d'"encre" nécessaire pour représenter un graphique**, autrement dit, plus le graphique est simple et sobre, mieux c'est. Le thème par défaut de `chart()` respecte mieux tout ceci^[Notez que plusieurs thèmes existent dans **ggplot2**. Il est facile d'en changer et de les personnaliser... mais c'est toujours appréciable d'avoir un rendu impeccable dès le premier essai.].

- La taille des caractères est légèrement plus grande dans la Fig. \@ref(fig:chart-example) réalisée avec `chart()` (surtout pour les nombres sur les axes). Le manque de lisibilité des parties textuelles dans un graphique est un défaut fréquent, dépendant de la résolution et de la taille de reproduction du graphique dans le document final. Le choix de `chart()` recule un peu ce risque.

- `chart()` est capable d'aller lire les métadonnées (libellés en français et unités des variables) et les utilisent automatiquement pour proposer des libellés corrects et complets des axes par défaut. `ggplot()` ne peut pas le faire, et il faut utiliser la fonction `labs()` pour l'indiquer manuellement.

```{block2, type='info'}
De manière générale, par rapport à `ggplot()`, `chart()` a été conçu pour produire le graphique le plus proche d'un rendu final impeccable avec tous les paramètres par défaut.
```

Quelques règles simples vous permettent de passer des **instructions** `ggplot()` à `chart()` et _vice versa_^[Étant donné l'abondante littérature écrite sur {ggplot2}, il est utile de pouvoir convertir des exemples {ggplot2} en graphiques `chart()`, si vous êtes convaincu par cette nouvelle interface.]\ :

1. On peut toujours remplacer `ggplot()` par `chart()` dans les instructions R (à condition que le package {chart} soit chargé bien sûr, par exemple via `SciViews::R`). Dans ce cas, le thème par défaut diffère, et le libellé automatique des axes (non disponible avec `ggplot()`) est activé.

2. Avec `chart()` on peut utiliser `aes()` pour spécifier les "esthétiques" (éléments à visualiser sur le graphique) comme pour `ggplot()`, mais on peut _aussi_ utiliser une interface formule plus compacte. Cette interface formule rapproche la version `chart()` des graphiques {ggplot2} d'un autre moteur de graphique dans R\ : {lattice}.

3. Outre les esthétiques classiques `x` et `y`, l'interface formule de `chart()` permet d'en inclure d'autres directement dans la formule à l'aide d'opérateurs spécifiques `%<esth>%=`. Par exemple, `aes(x = weight, y = height, col = origin)` dans la Fig. \@ref(fig:ggplot2-example) se traduit en la formule plus concise `height ~ weight %col=% origin` avec `chart()` (notez la position _inversée_ de `x` et `y ` dans la formule puisqu'on a `y ~ x`). **Tous** les esthétiques de {ggplot2} sont supportés de cette manière.

4. Partout où `aes()` est utilisé pour les instructions {ggplot2}, on peut utiliser à la place `f_aes()` et y spécifier plutôt une formule de type `chart()`.

5. Avec `ggplot()` les facettes doivent être spécifiées à l'aide de `facet_XXX()`. A condition d'utiliser `chart()`, il est possible d'inclure les spécifications des facettes les plus utilisées directement dans la formule en utilisant l'opérateur `|`. Cette façon de procéder est, encore une fois, identique à ce qui se fait dans {lattice} (voir plus loin).

Le point (5) mérite une petite démonstration pour comparaison\ :

```{r chart-ggplot2-facets, fig.cap= "Graphique à facettes. A. version `chart()`, B. version `ggplot()`."}
a <- chart(data = urchin, height ~ weight | origin) + 
  geom_point() 

b <- ggplot(data = urchin, mapping = aes(x = weight, y = height)) + 
  geom_point() +
  facet_grid( ~ origin)

combine_charts(list(a, b))
```

##### Exercez-vous {-}

```{block2, type = "bdd"}

Afin de vous exercer à réaliser des graphiques `chart()`/`ggplot()`, proposez trois graphiques inédits (qui n'ont pas été vu jusqu'ici) dans vos différents projets (assignations GitHub Classroom). Employez par exemple les liens suivants pour vous inspirer\ :

- <https://www.r-graph-gallery.com>

- <http://r-statistics.co/Top50-Ggplot2-Visualizations-MasterList-R-Code.html>

```

::: {.S-BIOG-006 .S-BIOG-027}

```{block2, type = "bdd"}
Dans le cadre d'une collaboration entre le cours English For Science et le cours de Science des données I, vous êtes amené créer et à maintenir un blog scientifique. 

Ce blog va comprendre des articles qui traitent d'analyse de la littérature de vulgarisation scientifique et de description de données.

Vous devez à présent ajouter un nouvel article qui va décrire un graphique de votre choix. 

Les consignes sont disponible dans le README du template <https://github.com/BioDataScience-Course/blog-template>
```

:::

##### Pour en savoir plus {-}

- Chapitre [Data visualisation](http://r4ds.had.co.nz/data-visualisation.html) de R for Data Science qui utilise `ggplot()`. 

- Site rassemblant des [extensions pour ggplot2](https://exts.ggplot2.tidyverse.org/gallery/)

**La suite de cette section est facultative\ : elle est importante pour comprendre les différents types de graphiques que vous allez rencontrer avec R. Cependant, si vous vous cantonnez aux graphiques `chart()`/`ggplot()` vous pouvez déjà réaliser énormément de visualisations différentes sans forcément connaitre les autres moteurs graphiques existant dans R.**

### {lattice}

Autant {ggplot2} est complètement modulable en ajoutant littéralement à l'aide de l'opérateur `+` des couches successives sur le graphique, autant {lattice} vise à réaliser les graphiques **en une seule instruction**. {lattice} utilise également abondamment l'interface formule pour spécifier les variables à utiliser dans le graphique. La version {lattice} du graphique d'exemple est présentée à la Fig. \@ref(fig:lattice-example).

```{r lattice-example, fig.cap= "Graphique exemple réalisé avec **lattice**."}
xyplot(height ~ weight, data = urchin, groups = origin, auto.key = TRUE)
```

Et voici la version `chart()` utilisant le moteur {lattice}. Notez la façon d'appeler la fonction `xyplot()` de {lattice} via `chart$xyplot()` :

```{r chart-lattice-example, fig.cap= "Graphique exemple réalisé avec `chart()` A. avec le moteur **lattice**, B. avec le moteur **ggplot2**."}
theme_sciviews_lattice(n = 2)
a <- chart$xyplot(height ~ weight, data = urchin, groups = origin,
  auto.key = list(space = "right", title = "Origine", cex.title = 1, columns = 1),
  ylab = "Hauteur du test [mm]", xlab = "Masse totale [g]",
  par.settings = list(superpose.symbol = list(col = scales::hue_pal()(2))))

b <- chart(data = urchin, height ~ weight %col=% origin) + 
  geom_point() 

combine_charts(list(a, b))
```

La quantité d'instructions nécessaires pour rendre la version {lattice} proche de la version {ggplot2} devrait disparaître dans les prochaines versions de `chart()`. Un autre objectif est aussi de gommer le plus possible les différences entre les rendus des différents moteurs de graphiques R, et en particuliers entre {ggplot2} et {lattice}. Comparez la Fig. \@ref(fig:chart-lattice-example)A avec la Fig. \@ref(fig:lattice-example) pour apprécier le gain déjà obtenu en matière d'homogénéisation.

```{block2, type='info'}
Par rapport à {ggplot2}, les graphiques {lattice} sont moins flexibles du fait qu'ils doivent être spécifiés en une seule instruction. Cependant, ils sont beaucoup plus rapides à générer (appréciable quand il y a beaucoup de points à tracer)\ ! {lattice} offre également quelques types de graphiques non supportés par {ggplot2} comme les graphiques en 3D à facettes, par exemple.
```

Voici un graphique à facettes réalisé avec `chart()` et le moteur {lattice}. Notez que la formule utilisée est *identique* à celle employée pour la version {ggplot2} avec `chart()`.

```{r lattice-facets, fig.cap= "Graphique à facettes, avec `chart()` version {lattice}."}
chart$xyplot(data = urchin, height ~ weight | origin,
  scales = list(alternating = 1),
  xlab = "Masse totale [g]", ylab = "Hauteur du test [mm]")
```

Mise à part les instructions additionnelles encore nécessaires dans cette version de `chart()`, l'appel et le rendu sont très similaires par rapport à la version {ggplot2} du même graphique avec `chart()` :

```{r ggplot2-facets2, fig.cap= "Graphique à facettes, avec `chart()` version {ggplot2}."}
chart(data = urchin, height ~ weight | origin) + 
  geom_point()
```

### Graphiques de base

Comme son nom le suggère, le moteur graphique de base est celui qui est implémenté de manière natif dans R. Il est donc utilisé un peu partout. Il est vieillissant et est plus difficile à manipuler que {ggplot2} certainement, et même que {lattice}. Néanmoins, il est très flexible et rapide, et encore beaucoup utilisé,... mais son rendu par défaut n'est plus vraiment au goût du jour. Voici notre graphique d'exemple rendu avec le moteur graphique R de base\ :

```{r base-example, fig.cap="Graphique exemple réalisé avec le moteur graphique R de base."}
plot(urchin$weight, urchin$height,
  col = c("red", "darkgreen")[urchin$origin], pch = 1)
legend(x = 80, y = 10, legend = c("Culture", "Pêcherie"),
  col = c("red", "darkgreen"), pch = 1)
```

Vous rencontrerez très fréquemment la fonction `plot()`. C'est une fonction dite **générique** dont le comportement change en fonction de l'objet fourni en premier argument. Ainsi, elle réalise le graphique le plus pertinent à chaque fois en fonction du contexte. Notez tout de suite les instructions un peu confuses nécessaires pour spécifier la couleur souhaitée en fonction de l'origine des oursins. Le moteur graphique de base ne gère **pas** automatiquement des aspects plus complexes du graphique, telle que le positionnement d'une légende. Donc, à moins d'avoir prévu la place suffisante _avant_ de tracer le graphique, nous ne pouvons que l'inclure à l'intérieur du cadre du graphique dans un second temps à l'aide de la fonction `legend()`. Comme cette dernière ne comprend rien à ce qui a été réalisé jusqu'ici, il faut lui respécifier les couleurs, formes et tailles de points utilisés\ ! C'est un des aspects pénibles du moteur graphique R de base.

Voici maintenant une version `chart()` de ce graphique de base\ :

```{r chart-base, fig.keep=2, fig.cap="Graphique exemple réalisé avec le moteur graphique de base et la fonction `chart()`."}
chart$base({
  par(mar = c(5.1, 4.1, 4.1, 6.1))
  plot(urchin$weight, urchin$height,
    col = scales::hue_pal()(2)[urchin$origin], pch = 19, cex = 0.8,
    xlab = "Masse totale [g]", ylab = "Hauteur du test [mm]")
  legend(x = 105, y = 20, legend = c("Culture", "Pêcherie"), title = "Origine",
    col = scales::hue_pal()(2), pch = 19, bty = "n", cex = 0.8, y.intersp = 2)
})
```

```{block2, type='note'}
Vous ne le voyez pas dans le bookdown, mais vous le réaliserez si vous utilisez ce genre de code dans vos propres documents R Markdown\ : le graphique est en réalité généré deux fois\ : une première fois dans un format propre aux graphiques R de base, et ensuite, il est traduit en une forme compatible avec les autres graphiques {ggplot2} et {lattice} (et au passage, il gagne la grille en traits grisés). Dans le chunck, nous devons spécifier `fig.keep = 2` si nous voulons éviter d'imprimer la première version dans le rapport lorsqu'on utilise `chart$base()`.
```

Pour l'instant, le seul avantage de `chart()` avec les graphiques de base est qu'il les convertit en une forme combinable avec les autres graphiques dans une figure composite (sinon, ce n'est pas possible). A part cela, il faut fournir à `chart$base()` tout le code nécessaire pour tracer et personnaliser le graphique. Comme on peut le voir sur cet exemple, cela demande une quantité considérable de code. C'est aussi un autre aspect pénible de ce moteur graphique\ : il est très flexible, mais l'interface n'est pas optimale. Pour finir, les graphiques de base ont plus de mal avec les facettes, mais il peuvent quand même générer les versions les plus simples, par exemple à l'aide de la fonction `coplot()` qui accepte une formule très similaire à ce que nous avons employé jusqu'ici, mais avec un rendu différent\ :

```{r coplot-example, fig.cap="Graphique à facettes avec le moteur graphique de base."}
coplot(data = urchin, height ~ weight | origin)
```

A l'issue de cette comparaison, vous pourrez décider du moteur graphique que vous préférerez utiliser. Dans le cadre de ce cours, nous n'utiliserons en tous cas que quasi-exclusivement des graphiques {ggplot2} créés à l'aide la fonction `chart()`.

##### Pour en savoir plus {-}

- [Introduction rapide à lattice](https://www.statmethods.net/advgraphs/trellis.html)

- [Variantes de graphiques avec lattice](https://www.r-bloggers.com/conditioning-and-grouping-with-lattice-graphics/)

- [Comparaison de lattice et ggplot2](https://learnr.wordpress.com/2009/08/26/ggplot2-version-of-figures-in-lattice-multivariate-data-visualization-with-r-final-part/). Cette page fait aussi référence à un ensemble de graphiques différents générés en {lattice} et en {ggplot2} pour comparaison (en anglais).

- [Divers exemples de graphiques réalisés avec le moteur de base](http://bl.ocks.org/patilv/raw/7360425/)

- [Autres exemples de graphiques R de base](http://www.sthda.com/english/wiki/scatter-plots-r-base-graphs)

- [ggplot2 comparé aux graphiques R de base](https://flowingdata.com/2016/03/22/comparing-ggplot2-and-r-base-graphics/). Un point de vue différent d'un utilisateur habitué aux graphiques R de base (en anglais).

## Récapitulatif des exercices

Ce module 4 vous a permis de réaliser et de découvrir de nouveau graphiques. Vous savez maintenant réaliser des graphiques en barres, des graphiques en camembert et des boites de dispersion. Vous êtes aussi capable de réaliser des graphiques composés. Pour évaluer votre compréhension de cette matière vous aviez les exercices suivants à réaliser\ :

`r show_ex_toc()`
